<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <title>星空闪烁旋转特效（Canvas 完全还原版）</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      height: 100%;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="starCanvas"></canvas>

  <script>
    (() => {
      const canvas = document.getElementById("starCanvas");
      const ctx = canvas.getContext("2d");
      let w, h;
      const STAR_COUNT = 280; // 数量可修改
      const stars = [];
      let rotation = 0;
      const ROTATE_SPEED = (2 * Math.PI) / (250 * 1000); // 与 CSS 250s 一致

      function resize() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resize);
      resize();

      // === 模拟 CSS blink 动画 ===
      function blinkProgress(p) {
        // p ∈ [0,1]
        if (p < 0.04) {
          return lerp(0.1, 0.9, p / 0.04);
        } else if (p < 0.08) {
          return lerp(0.9, 0.1, (p - 0.04) / 0.04);
        } else if (p < 0.5) {
          return 0.1;
        } else if (p < 0.52) {
          return lerp(0.1, 0.3, (p - 0.5) / 0.02);
        } else if (p < 0.54) {
          return lerp(0.3, 0.1, (p - 0.52) / 0.02);
        } else {
          return 0.1;
        }
      }

      function lerp(a, b, t) {
        return a + (b - a) * t;
      }

      // 生成随机星星
      for (let i = 0; i < STAR_COUNT; i++) {
        const colorType = i % 8 === 0 ? "red" : i % 10 === 6 ? "blue" : "white";
        const delay = Math.random() * 15; // 秒
        stars.push({
          x: Math.random() * w * 2 - w / 2,
          y: Math.random() * h * 2 - h / 2,
          size: 7 + Math.random() * 2,
          opacity: 0.5 + Math.random() * 0.5,
          delay: delay,
          color: colorType,
        });
      }

      // 绘制单个星星
      function drawStar(star, scale) {
        const { size, color, opacity } = star;
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
        if (color === "red") {
          gradient.addColorStop(0, `rgba(255,0,0,${opacity})`);
          gradient.addColorStop(1, "rgba(255,0,0,0)");
        } else if (color === "blue") {
          gradient.addColorStop(0, `rgba(0,0,255,${opacity})`);
          gradient.addColorStop(1, "rgba(0,0,255,0)");
        } else {
          gradient.addColorStop(0, `rgba(255,255,255,${opacity})`);
          gradient.addColorStop(1, "rgba(255,255,255,0)");
        }

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, size * scale, 0, Math.PI * 2);
        ctx.fill();

        // 星芒十字
        ctx.save();
        const glowColor =
          color === "red"
            ? "rgba(255,0,0,0.8)"
            : color === "blue"
              ? "rgba(0,0,255,0.8)"
              : "rgba(255,255,255,0.8)";
        ctx.strokeStyle = glowColor;
        ctx.lineWidth = 1.2;
        ctx.globalAlpha = opacity * 0.8;
        for (let i = 0; i < 2; i++) {
          ctx.beginPath();
          ctx.moveTo(-size * 2 * scale, 0);
          ctx.lineTo(size * 2 * scale, 0);
          ctx.stroke();
          ctx.rotate(Math.PI / 2);
        }
        ctx.restore();
      }

      function animate(t) {
        ctx.clearRect(0, 0, w, h);
        ctx.save();
        ctx.translate(w / 2, h / 2);
        rotation += ROTATE_SPEED * 16.67; // 按帧近似（60fps）
        ctx.rotate(rotation);

        for (const star of stars) {
          const time = (t / 1000 + star.delay) % 15; // 15s 一周期
          const progress = time / 15;
          const scale = blinkProgress(progress); // 与原CSS一致

          ctx.save();
          ctx.translate(star.x, star.y);
          drawStar(star, scale);
          ctx.restore();
        }

        ctx.restore();
        requestAnimationFrame(animate);
      }

      requestAnimationFrame(animate);
    })();
  </script>
</body>

</html>